<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ListBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">crafter</a> &gt; <a href="index.source.html" class="el_package">com.brianmearns.crafter</a> &gt; <span class="el_source">ListBuilder.java</span></div><h1>ListBuilder.java</h1><pre class="source lang-java linenums">package com.brianmearns.crafter;

import com.brianmearns.crafter.util.SupplierFunctions;
import com.google.common.base.Function;
import com.google.common.base.Supplier;
import com.google.common.base.Suppliers;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import com.google.common.collect.Lists;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.*;

/**
 * A {@link Builder} for a list of values.
 *
 * @author Brian Mearns &lt;bmearns@ieee.org&gt;
 */
@SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L23">public abstract class ListBuilder&lt;T&gt; implements Builder&lt;List&lt;T&gt;&gt; {</span>

    /**
     * Static factory method to create an instance.
     */
    @NotNull
    @Contract(&quot;-&gt; !null&quot;)
    public static &lt;T&gt; ListBuilder&lt;T&gt; create() {
<span class="fc" id="L31">        return new DefaultListBuilder&lt;&gt;();</span>
    }

    /**
     * Static factory method to create an instance.
     * @param cls Specifies the type {@code T} of the builder returned.
     */
    @NotNull
    @Contract(&quot;_ -&gt; !null&quot;)
    public static &lt;T&gt; ListBuilder&lt;T&gt; create(Class&lt;T&gt; cls) {
<span class="fc" id="L41">        return new DefaultListBuilder&lt;&gt;();</span>
    }

    /**
     * Helper method for adding an element as a supplier of that element.
     * @param element Supplier of the element to add.
     *
     * @return {@code this} object itself, for chaining convenience.
     */
    @NotNull
    @Contract(&quot;_ -&gt; !null&quot;)
    protected abstract ListBuilder&lt;T&gt; add(@NotNull Supplier&lt;? extends T&gt; element);

    /**
     * Helper method for adding an iterable of suppliers of elements.
     *
     * @param elements Suppliers for all the elements to add.
     *
     * @return {@code this} object itself, for chaining convenience.
     */
    @NotNull
    @Contract(&quot;_ -&gt; !null&quot;)
    protected abstract ListBuilder&lt;T&gt; addSuppliers(@NotNull Iterable&lt;? extends Supplier&lt;? extends T&gt;&gt; elements);

    /**
     * Helper method for adding an iterator of suppliers of elements.
     *
     * @param elements Suppliers for all the elements to add.
     *
     * @return {@code this} object itself, for chaining convenience.
     */
    @NotNull
    @Contract(&quot;_ -&gt; !null&quot;)
    protected abstract ListBuilder&lt;T&gt; addSuppliers(@NotNull Iterator&lt;? extends Supplier&lt;? extends T&gt;&gt; elements);

    /**
     * Helper method for adding an array of suppliers of elements.
     *
     * @param elements Suppliers for all the elements to add.
     *
     * @return {@code this} object itself, for chaining convenience.
     */
    @NotNull
    protected abstract ListBuilder&lt;T&gt; addSuppliers(@NotNull Supplier&lt;? extends T&gt;[] elements);

    /**
     * Helper method to add the given element, if and only if the given boolean is {@code true}. Otherwise
     * has no effect on the state of the builder.
     *
     * @param element A supplier for the element to {@link #add(Supplier)}.
     * @param add Whether or not to add the element.
     *
     * @return {@code this} object itself, for chaining convenience.
     */
    @NotNull
    protected abstract ListBuilder&lt;T&gt; maybeAdd(@NotNull Supplier&lt;? extends T&gt; element, boolean add);

    /**
     * Add all of the given elements, in order, to the list of values.
     *
     * @param elements An {@link Iterable} of the elements to add.
     *
     * @return {@code this} object itself, for chaining convenience.
     *
     * @see #addAll(Iterator)
     * @see #addAll(Object[])
     * @see #addBuilders(Iterable)
     */
    @NotNull
    public ListBuilder&lt;T&gt; addAll(@NotNull Iterable&lt;? extends T&gt; elements) {
<span class="fc" id="L111">        return addSuppliers(Iterables.transform(elements, SupplierFunctions.&lt;T&gt;supplierOfInstanceFunction()));</span>
    }

    /**
     * Add all of the given {@link Builder Builders}, in order, as builders of element values to the end of the list.
     *
     * &lt;p&gt;
     * As with {@link #add(Builder)}, this does not invoke any of the builders immediately to build the element value.
     * Each builder will be invoked once during a call to {@link #get()}.
     *
     * @param elements An {@link Iterable} of the builders to add.
     *
     * @return {@code this} object itself, for chaining convenience.
     *
     * @see #addBuilders(Iterator)
     * @see #addBuilders(Builder[])
     * @see #addAll(Iterable)
     */
    @NotNull
    @Contract(&quot;_ -&gt; !null&quot;)
    public ListBuilder&lt;T&gt; addBuilders(@NotNull Iterable&lt;? extends Builder&lt;? extends T&gt;&gt; elements) {
<span class="fc" id="L132">        return addSuppliers(elements);</span>
    }

    /**
     * Add all of the given elements, in order, to the list of values.
     *
     * @param elements An {@link Iterator} over the elements to add.
     *
     * @return {@code this} object itself, for chaining convenience.
     *
     * @see #addAll(Iterable)
     * @see #addAll(Object[])
     * @see #addBuilders(Iterator)
     */
    @NotNull
    @Contract(&quot;_ -&gt; !null&quot;)
    public ListBuilder&lt;T&gt; addAll(@NotNull Iterator&lt;? extends T&gt; elements) {
<span class="fc" id="L149">        return addSuppliers(Iterators.transform(elements, SupplierFunctions.&lt;T&gt;supplierOfInstanceFunction()));</span>
    }

    /**
     * Add all of the given {@link Builder Builders}, in order, as builders of element values to the end of the list.
     *
     * &lt;p&gt;
     * As with {@link #add(Builder)}, this does not invoke any of the builders immediately to build the element value.
     * Each builder will be invoked once during a call to {@link #get()}.
     *
     * @param elements An {@link Iterator} over the builders to add.
     *
     * @return {@code this} object itself, for chaining convenience.
     *
     * @see #addBuilders(Iterable)
     * @see #addBuilders(Builder[])
     * @see #addAll(Iterator)
     */
    @NotNull
    @Contract(&quot;_ -&gt; !null&quot;)
    public ListBuilder&lt;T&gt; addBuilders(@NotNull Iterator&lt;? extends Builder&lt;? extends T&gt;&gt; elements) {
<span class="fc" id="L170">        return addSuppliers(elements);</span>
    }

    /**
     * Add all of the given elements, in order, to the list of values.
     *
     * @param elements An array of the elements to add.
     *
     * @return {@code this} object itself, for chaining convenience.
     *
     * @see #addAll(Iterable)
     * @see #addAll(Iterator)
     * @see #addBuilders(Builder[])
     */
    @NotNull
    @Contract(&quot;_ -&gt; !null&quot;)
    public ListBuilder&lt;T&gt; addAll(@NotNull T[] elements) {
<span class="fc" id="L187">        return addSuppliers(Iterables.transform(Arrays.asList(elements), SupplierFunctions.&lt;T&gt;supplierOfInstanceFunction()));</span>
    }

    /**
     * Add all of the given {@link Builder Builders}, in order, as builders of element values to the end of the list.
     *
     * &lt;p&gt;
     * As with {@link #add(Builder)}, this does not invoke any of the builders immediately to build the element value.
     * Each builder will be invoked once during a call to {@link #get()}.
     *
     * @param elements An array of the builders to add.
     *
     * @return {@code this} object itself, for chaining convenience.
     *
     * @see #addBuilders(Iterable)
     * @see #addBuilders(Iterator)
     * @see #addAll(Object[])
     */
    @NotNull
    @Contract(&quot;_ -&gt; !null&quot;)
    public ListBuilder&lt;T&gt; addBuilders(@NotNull Builder&lt;? extends T&gt;[] elements) {
<span class="fc" id="L208">        return addSuppliers(elements);</span>
    }

    /**
     * Add the given item as the next element in the list.
     *
     * @param element The element to append to the list.
     *
     * @return {@code this} object itself, for chaining convenience.
     */
    @NotNull
    @Contract(&quot;_ -&gt; !null&quot;)
    public ListBuilder&lt;T&gt; add(@Nullable T element) {
<span class="fc" id="L221">        return add(Suppliers.ofInstance(element));</span>
    }

    /**
     * Add the given {@link Builder} as a builder for the next item in the list. The builder is not invoked to build
     * the value immediately, its {@link Builder#get()} method is invoked to build the element value only when &lt;em&gt;this&lt;/em&gt;
     * object's {@link #get()} method is invoked to build a list of values.
     *
     * @param elementBuilder Builder for the element to put at the end of the current list of elements.
     *
     * @return {@code this} object itself, for chaining convenience.
     */
    @NotNull
    @Contract(&quot;_ -&gt; !null&quot;)
    public ListBuilder&lt;T&gt; add(@NotNull Builder&lt;? extends T&gt; elementBuilder) {
<span class="fc" id="L236">        return add((Supplier&lt;? extends T&gt;) elementBuilder);</span>
    }

    /**
     * Adds the given element, if and only if the given boolean is {@code true}. Otherwise
     * has no effect on the state of the builder.
     *
     * @param element The element value to {@link #add(Object)}.
     * @param add Whether or not to add the element.
     *
     * @return {@code this} object itself, for chaining convenience.
     */
    @NotNull
    @Contract(&quot;_, _ -&gt; !null&quot;)
    public ListBuilder&lt;T&gt; maybeAdd(@Nullable T element, boolean add) {
<span class="fc" id="L251">        return maybeAdd(Suppliers.ofInstance(element), add);</span>
    }

    /**
     * Build a new list using the elements specified for this builder.
     *
     * @return The built list of elements.
     */
    @NotNull
    @Contract(&quot;-&gt; !null&quot;)
    @Override
    public abstract List&lt;T&gt; get() throws IncompleteBuilderException;

    /**
     * Adds the given element builder for the next item in the list, if and only if the
     * given boolean is {@code true}. Otherwise has no effect on the state of the builder.
     *
     * @param element The element value to {@link #add(Builder)}.
     * @param add Whether or not to add the element.
     *
     * @return {@code this} object itself, for chaining convenience.
     */
    @NotNull
    @Contract(&quot;_, _ -&gt; !null&quot;)
    public ListBuilder&lt;T&gt; maybeAdd(@NotNull Builder&lt;? extends T&gt; element, boolean add) {
<span class="fc" id="L276">        return maybeAdd((Supplier&lt;? extends T&gt;) element, add);</span>
    }

    /**
     * Apply the given function to {@code this} object, and return {@code this} object again.
     *
     * &lt;p&gt;
     * This is simply a way to add some arbitrary code in the middle of a chain of method invocations.
     * You could use the {@link Function} to perform some complex logic to configure the builder, for instance.
     *
     * &lt;p&gt;
     * The return value of the function is ignored, but for safety and clarity, it should be a void return.
     *
     * @param function The {@link Function} to be invoked on {@code this} object.
     *
     * @return This {@code ListBuilder} itself, for chaining convenience.
     */
    @NotNull
    public abstract ListBuilder&lt;T&gt; apply(@NotNull Function&lt;ListBuilder&lt;T&gt;, Void&gt; function);

    /**
     * Returns the top-level non-conditional builder.
     */
    @NotNull
    @Contract(&quot;-&gt; !null&quot;)
    public abstract ListBuilder&lt;T&gt; always();

    /**
     * Returns a builder which either does or doesn't delegate to this builder based on the given boolean.
     * @param yes If {@code true}, then methods invoked on the returned builder will modify the state of {@code this}
     *            builder. Otherwise, methods invoked on the returned builder will not modify state.
     */
    @NotNull
    public abstract ListBuilder&lt;T&gt; maybe(boolean yes);

    /**
     * Returns the parent list builder of a conditional list builder. This is not necessarily the originating top level
     * builder if you have nested (or rather chained) calls to {@link #maybe(boolean)}.
     */
    @NotNull
    public abstract ListBuilder&lt;T&gt; endMaybe();

    @SuppressWarnings(&quot;unused&quot;)
    protected static class DefaultListBuilder&lt;T&gt; extends ListBuilder&lt;T&gt; {

        @NotNull
        private final List&lt;Supplier&lt;? extends T&gt;&gt; elements;

        {
            //Linked list is good because we're mostly just appending to it, and then iterating through it.
            // Linked lists are pretty good at both.
<span class="fc" id="L327">            elements = new LinkedList&lt;&gt;();</span>
        }

<span class="fc" id="L330">        public DefaultListBuilder() {</span>

<span class="fc" id="L332">        }</span>

        /**
         * Helper method to actually build the list returned by {@link #get()}.
         *
         * &lt;p&gt;
         * This can be overridden if you need to create a different type of {@link List}. The
         * default implementation produces an {@link ArrayList}.
         *
         * &lt;p&gt;
         * Be careful how you implement this. The given {@link Supplier suppliers} should
         * be {@linkplain Supplier#get() invoked} exactly once per call to this method, and
         * they should be invoked from within this method. For instance, things like
         * {@link Lists#transform(List, Function)} do &quot;lazy&quot; evaluation which invokes the
         * supplier everytime the element is accessed in the returned list. This is &lt;em&gt;not&lt;/em&gt;
         * suitable for use with this method.
         *
         * @param suppliers An immutable list of the suppliers for the element values.
         *
         * @return A list that will be returned by this object's {@link #get()} method.
         */
        @NotNull
        @Contract(&quot;_ -&gt; !null&quot;)
        protected List&lt;T&gt; get(@NotNull ImmutableList&lt;Supplier&lt;? extends T&gt;&gt; suppliers) {
<span class="fc" id="L356">            ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;(suppliers.size());</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">            for (Supplier&lt;? extends T&gt; supplier : suppliers) {</span>
<span class="fc" id="L358">                list.add(supplier.get());</span>
<span class="fc" id="L359">            }</span>
<span class="fc" id="L360">            return list;</span>
        }

        @Override
        @NotNull
        @Contract(&quot;_ -&gt; !null&quot;)
        protected ListBuilder&lt;T&gt; add(@NotNull Supplier&lt;? extends T&gt; element) {
<span class="fc" id="L367">            elements.add(element);</span>
<span class="fc" id="L368">            return this;</span>
        }

        @Override
        @NotNull
        @Contract(&quot;_ -&gt; !null&quot;)
        protected ListBuilder&lt;T&gt; addSuppliers(@NotNull Iterable&lt;? extends Supplier&lt;? extends T&gt;&gt; elements) {
<span class="fc" id="L375">            Iterables.addAll(this.elements, elements);</span>
<span class="fc" id="L376">            return this;</span>
        }

        @Override
        @NotNull
        @Contract(&quot;_ -&gt; !null&quot;)
        protected ListBuilder&lt;T&gt; addSuppliers(@NotNull Iterator&lt;? extends Supplier&lt;? extends T&gt;&gt; elements) {
<span class="fc bfc" id="L383" title="All 2 branches covered.">            while(elements.hasNext()) {</span>
<span class="fc" id="L384">                this.elements.add(elements.next());</span>
            }
<span class="fc" id="L386">            return this;</span>
        }

        @Override
        @NotNull
        protected ListBuilder&lt;T&gt; addSuppliers(@NotNull Supplier&lt;? extends T&gt;[] elements) {
<span class="fc" id="L392">            return addSuppliers(Arrays.asList(elements));</span>
        }

        @Override
        @NotNull
        @Contract(&quot;_, _ -&gt; !null&quot;)
        protected ListBuilder&lt;T&gt; maybeAdd(@NotNull Supplier&lt;? extends T&gt; element, boolean add) {
<span class="fc bfc" id="L399" title="All 2 branches covered.">            if(add) {</span>
<span class="fc" id="L400">                this.add(element);</span>
            }
<span class="fc" id="L402">            return this;</span>
        }

        @Override
        @NotNull
        @Contract(&quot;_ -&gt; !null&quot;)
        public ListBuilder&lt;T&gt; apply(@NotNull Function&lt;ListBuilder&lt;T&gt;, Void&gt; function) {
<span class="fc" id="L409">            function.apply(this);</span>
<span class="fc" id="L410">            return this;</span>
        }

        /**
         * Build a new list using the elements specified for this builder.
         *
         * &lt;p&gt;
         * Note that this delegates to {@link #get(ImmutableList)}.
         * &lt;/p&gt;
         *
         * @return The built list of elements.
         */
        @NotNull
        @Override
        public List&lt;T&gt; get() throws IncompleteBuilderException {
<span class="fc" id="L425">            return get(ImmutableList.copyOf(elements));</span>
        }

        /**
         * Returns itself.
         */
        @Override
        @NotNull
        @Contract(pure=true)
        public ListBuilder&lt;T&gt; always() {
<span class="fc" id="L435">            return this;</span>
        }

        /**
         * Returns either {@code this} object itself, or a new {@link NeverListBuilder} if {@code yes} is {@code false}.
         */
        @Override
        @NotNull
        public ListBuilder&lt;T&gt; maybe(boolean yes) {
<span class="fc bfc" id="L444" title="All 2 branches covered.">            if(yes) {</span>
<span class="fc" id="L445">                return this;</span>
            } else {
<span class="fc" id="L447">                return new NeverListBuilder&lt;&gt;(this, this);</span>
            }
        }

        @NotNull
        @Override
        @Contract(pure=true)
        public ListBuilder&lt;T&gt; endMaybe() {
<span class="fc" id="L455">            return this;</span>
        }

    }

    /**
     * A {@link ListBuilder} which doesn't actually do anything.
     */
<span class="fc" id="L463">    protected static class NeverListBuilder&lt;T&gt; extends ListBuilder&lt;T&gt; {</span>

        @NotNull
        private final ListBuilder&lt;T&gt; alwaysBuilder;

        @NotNull
        private final ListBuilder&lt;T&gt; parent;

<span class="fc" id="L471">        protected NeverListBuilder(@NotNull ListBuilder&lt;T&gt; alwaysBuilder, @NotNull ListBuilder&lt;T&gt; parent) {</span>
<span class="fc" id="L472">            this.alwaysBuilder = alwaysBuilder;</span>
<span class="fc" id="L473">            this.parent = parent;</span>
<span class="fc" id="L474">        }</span>

        @Override
        @NotNull
        @Contract(pure=true)
        protected ListBuilder&lt;T&gt; add(@NotNull Supplier&lt;? extends T&gt; element) {
<span class="fc" id="L480">            return this;</span>
        }

        @Override
        @NotNull
        @Contract(pure=true)
        protected ListBuilder&lt;T&gt; addSuppliers(@NotNull Iterable&lt;? extends Supplier&lt;? extends T&gt;&gt; elements) {
<span class="fc" id="L487">            return this;</span>
        }

        @Override
        @NotNull
        @Contract(pure=true)
        protected ListBuilder&lt;T&gt; addSuppliers(@NotNull Iterator&lt;? extends Supplier&lt;? extends T&gt;&gt; elements) {
<span class="fc" id="L494">            return this;</span>
        }

        @Override
        @NotNull
        @Contract(pure=true)
        protected ListBuilder&lt;T&gt; addSuppliers(@NotNull Supplier&lt;? extends T&gt;[] elements) {
<span class="fc" id="L501">            return this;</span>
        }

        @Override
        @NotNull
        @Contract(pure=true)
        protected ListBuilder&lt;T&gt; maybeAdd(@NotNull Supplier&lt;? extends T&gt; element, boolean add) {
<span class="fc" id="L508">            return this;</span>
        }

        /**
         * Note that the never build &lt;em&gt;does not&lt;/em&gt; invoke the given function at all, it simply returns itself, as usual.
         */
        @NotNull
        @Override
        public ListBuilder&lt;T&gt; apply(@NotNull Function&lt;ListBuilder&lt;T&gt;, Void&gt; function) {
<span class="fc" id="L517">            return this;</span>
        }

        /**
         * Returns the originating (non-conditional) list builder.
         */
        @Override
        @NotNull
        @Contract(pure=true)
        public ListBuilder&lt;T&gt; always() {
<span class="fc" id="L527">            return alwaysBuilder;</span>
        }

        /**
         * Returns a new {@link NeverListBuilder} itself. Chaining two &quot;maybe&quot; calls is like an AND: so if this AND that,
         * then change the state of the builder. But if the first one is already false, it doesn't matter what the second
         * one is, the aggregate is false.
         */
        @Override
        @NotNull
        @Contract(pure=true)
        public ListBuilder&lt;T&gt; maybe(boolean yes) {
<span class="fc" id="L539">            return new NeverListBuilder&lt;&gt;(alwaysBuilder, this);</span>
        }

        @NotNull
        @Contract(pure=true)
        public ListBuilder&lt;T&gt; endMaybe() {
<span class="fc" id="L545">            return parent;</span>
        }

        /**
         * Delegates to the originating (non-conditional) list builder.
         */
        @Override
        @NotNull
        public List&lt;T&gt; get() throws IncompleteBuilderException {
<span class="fc" id="L554">            return alwaysBuilder.get();</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>