<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ListBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">crafter</a> &gt; <a href="index.source.html" class="el_package">com.brianmearns.crafter</a> &gt; <span class="el_source">ListBuilder.java</span></div><h1>ListBuilder.java</h1><pre class="source lang-java linenums">package com.brianmearns.crafter;

import com.brianmearns.crafter.util.SupplierFunctions;
import com.google.common.base.Function;
import com.google.common.base.Supplier;
import com.google.common.base.Suppliers;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import com.google.common.collect.Lists;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.util.*;

/**
 * A {@link BuilderInterface} for a list of values.
 *
 * @author Brian Mearns &lt;bmearns@ieee.org&gt;
 */
@SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L22">public abstract class ListBuilder&lt;T&gt; implements BuilderInterface&lt;List&lt;T&gt;&gt; {</span>

    /**
     * Static factory method to create an instance.
     */
    @Nonnull
    public static &lt;T&gt; ListBuilder&lt;T&gt; create() {
<span class="fc" id="L29">        return new DefaultListBuilder&lt;&gt;();</span>
    }

    /**
     * Static factory method to create an instance.
     * @param cls Specifies the type {@code T} of the builder returned.
     */
    @Nonnull
    public static &lt;T&gt; ListBuilder&lt;T&gt; create(Class&lt;T&gt; cls) {
<span class="fc" id="L38">        return new DefaultListBuilder&lt;&gt;();</span>
    }

    /**
     * Helper method for adding an element as a supplier of that element.
     * @param element Supplier of the element to add.
     *
     * @return {@code this} object itself, for chaining convenience.
     */
    @Nonnull
    protected abstract ListBuilder&lt;T&gt; add(@Nonnull Supplier&lt;? extends T&gt; element);

    /**
     * Helper method for adding an iterable of suppliers of elements.
     *
     * @param elements Suppliers for all the elements to add.
     *
     * @return {@code this} object itself, for chaining convenience.
     */
    @Nonnull
    protected abstract ListBuilder&lt;T&gt; addSuppliers(@Nonnull Iterable&lt;? extends Supplier&lt;? extends T&gt;&gt; elements);

    /**
     * Helper method for adding an iterator of suppliers of elements.
     *
     * @param elements Suppliers for all the elements to add.
     *
     * @return {@code this} object itself, for chaining convenience.
     */
    @Nonnull
    protected abstract ListBuilder&lt;T&gt; addSuppliers(@Nonnull Iterator&lt;? extends Supplier&lt;? extends T&gt;&gt; elements);

    /**
     * Helper method for adding an array of suppliers of elements.
     *
     * @param elements Suppliers for all the elements to add.
     *
     * @return {@code this} object itself, for chaining convenience.
     */
    @Nonnull
    protected abstract ListBuilder&lt;T&gt; addSuppliers(@Nonnull Supplier&lt;? extends T&gt;[] elements);

    /**
     * Helper method to add the given element, if and only if the given boolean is {@code true}. Otherwise
     * has no effect on the state of the builder.
     *
     * @param element A supplier for the element to {@link #add(Supplier)}.
     * @param add Whether or not to add the element.
     *
     * @return {@code this} object itself, for chaining convenience.
     */
    @Nonnull
    protected abstract ListBuilder&lt;T&gt; maybeAdd(@Nonnull Supplier&lt;? extends T&gt; element, boolean add);

    /**
     * Add all of the given elements, in order, to the list of values.
     *
     * @param elements An {@link Iterable} of the elements to add.
     *
     * @return {@code this} object itself, for chaining convenience.
     *
     * @see #addAll(Iterator)
     * @see #addAll(Object[])
     * @see #addBuilders(Iterable)
     */
    @Nonnull
    public ListBuilder&lt;T&gt; addAll(@Nonnull Iterable&lt;? extends T&gt; elements) {
<span class="fc" id="L105">        return addSuppliers(Iterables.transform(elements, SupplierFunctions.&lt;T&gt;supplierOfInstanceFunction()));</span>
    }

    /**
     * Add all of the given {@link BuilderInterface Builders}, in order, as builders of element values to the end of the list.
     *
     * &lt;p&gt;
     * As with {@link #add(BuilderInterface)}, this does not invoke any of the builders immediately to build the element value.
     * Each builder will be invoked once during a call to {@link #get()}.
     *
     * @param elements An {@link Iterable} of the builders to add.
     *
     * @return {@code this} object itself, for chaining convenience.
     *
     * @see #addBuilders(Iterator)
     * @see #addBuilders(BuilderInterface[])
     * @see #addAll(Iterable)
     */
    @Nonnull
    public ListBuilder&lt;T&gt; addBuilders(@Nonnull Iterable&lt;? extends BuilderInterface&lt;? extends T&gt;&gt; elements) {
<span class="fc" id="L125">        return addSuppliers(elements);</span>
    }

    /**
     * Add all of the given elements, in order, to the list of values.
     *
     * @param elements An {@link Iterator} over the elements to add.
     *
     * @return {@code this} object itself, for chaining convenience.
     *
     * @see #addAll(Iterable)
     * @see #addAll(Object[])
     * @see #addBuilders(Iterator)
     */
    @Nonnull
    public ListBuilder&lt;T&gt; addAll(@Nonnull Iterator&lt;? extends T&gt; elements) {
<span class="fc" id="L141">        return addSuppliers(Iterators.transform(elements, SupplierFunctions.&lt;T&gt;supplierOfInstanceFunction()));</span>
    }

    /**
     * Add all of the given {@link BuilderInterface Builders}, in order, as builders of element values to the end of the list.
     *
     * &lt;p&gt;
     * As with {@link #add(BuilderInterface)}, this does not invoke any of the builders immediately to build the element value.
     * Each builder will be invoked once during a call to {@link #get()}.
     *
     * @param elements An {@link Iterator} over the builders to add.
     *
     * @return {@code this} object itself, for chaining convenience.
     *
     * @see #addBuilders(Iterable)
     * @see #addBuilders(BuilderInterface[])
     * @see #addAll(Iterator)
     */
    @Nonnull
    public ListBuilder&lt;T&gt; addBuilders(@Nonnull Iterator&lt;? extends BuilderInterface&lt;? extends T&gt;&gt; elements) {
<span class="fc" id="L161">        return addSuppliers(elements);</span>
    }

    /**
     * Add all of the given elements, in order, to the list of values.
     *
     * @param elements An array of the elements to add.
     *
     * @return {@code this} object itself, for chaining convenience.
     *
     * @see #addAll(Iterable)
     * @see #addAll(Iterator)
     * @see #addBuilders(BuilderInterface[])
     */
    @Nonnull
    public ListBuilder&lt;T&gt; addAll(@Nonnull T[] elements) {
<span class="fc" id="L177">        return addSuppliers(Iterables.transform(Arrays.asList(elements), SupplierFunctions.&lt;T&gt;supplierOfInstanceFunction()));</span>
    }

    /**
     * Add all of the given {@link BuilderInterface Builders}, in order, as builders of element values to the end of the list.
     *
     * &lt;p&gt;
     * As with {@link #add(BuilderInterface)}, this does not invoke any of the builders immediately to build the element value.
     * Each builder will be invoked once during a call to {@link #get()}.
     *
     * @param elements An array of the builders to add.
     *
     * @return {@code this} object itself, for chaining convenience.
     *
     * @see #addBuilders(Iterable)
     * @see #addBuilders(Iterator)
     * @see #addAll(Object[])
     */
    @Nonnull
    public ListBuilder&lt;T&gt; addBuilders(@Nonnull BuilderInterface&lt;? extends T&gt;[] elements) {
<span class="fc" id="L197">        return addSuppliers(elements);</span>
    }

    /**
     * Add the given item as the next element in the list.
     *
     * @param element The element to append to the list.
     *
     * @return {@code this} object itself, for chaining convenience.
     */
    @Nonnull
    public ListBuilder&lt;T&gt; add(@Nullable T element) {
<span class="fc" id="L209">        return add(Suppliers.ofInstance(element));</span>
    }

    /**
     * Add the given {@link BuilderInterface} as a builder for the next item in the list. The builder is not invoked to build
     * the value immediately, its {@link BuilderInterface#get()} method is invoked to build the element value only when &lt;em&gt;this&lt;/em&gt;
     * object's {@link #get()} method is invoked to build a list of values.
     *
     * @param elementBuilder Builder for the element to put at the end of the current list of elements.
     *
     * @return {@code this} object itself, for chaining convenience.
     */
    @Nonnull
    public ListBuilder&lt;T&gt; add(@Nonnull BuilderInterface&lt;? extends T&gt; elementBuilder) {
<span class="fc" id="L223">        return add((Supplier&lt;? extends T&gt;) elementBuilder);</span>
    }

    /**
     * Adds the given element, if and only if the given boolean is {@code true}. Otherwise
     * has no effect on the state of the builder.
     *
     * @param element The element value to {@link #add(Object)}.
     * @param add Whether or not to add the element.
     *
     * @return {@code this} object itself, for chaining convenience.
     */
    @Nonnull
    public ListBuilder&lt;T&gt; maybeAdd(@Nullable T element, boolean add) {
<span class="fc" id="L237">        return maybeAdd(Suppliers.ofInstance(element), add);</span>
    }

    /**
     * Build a new list using the elements specified for this builder.
     *
     * @return The built list of elements.
     */
    @Nonnull
    @Override
    public abstract List&lt;T&gt; get() throws IncompleteBuilderException;

    /**
     * Adds the given element builder for the next item in the list, if and only if the
     * given boolean is {@code true}. Otherwise has no effect on the state of the builder.
     *
     * @param element The element value to {@link #add(BuilderInterface)}.
     * @param add Whether or not to add the element.
     *
     * @return {@code this} object itself, for chaining convenience.
     */
    @Nonnull
    public ListBuilder&lt;T&gt; maybeAdd(@Nonnull BuilderInterface&lt;? extends T&gt; element, boolean add) {
<span class="fc" id="L260">        return maybeAdd((Supplier&lt;? extends T&gt;) element, add);</span>
    }

    /**
     * Apply the given function to {@code this} object, and return {@code this} object again.
     *
     * &lt;p&gt;
     * This is simply a way to add some arbitrary code in the middle of a chain of method invocations.
     * You could use the {@link Function} to perform some complex logic to configure the builder, for instance.
     *
     * &lt;p&gt;
     * The return value of the function is ignored, but for safety and clarity, it should be a void return.
     *
     * @param function The {@link Function} to be invoked on {@code this} object.
     *
     * @return This {@code ListBuilder} itself, for chaining convenience.
     */
    @Nonnull
    public abstract ListBuilder&lt;T&gt; apply(@Nonnull Function&lt;ListBuilder&lt;T&gt;, Void&gt; function);

    /**
     * Returns the top-level non-conditional builder.
     */
    @Nonnull
    public abstract ListBuilder&lt;T&gt; always();

    /**
     * Returns a builder which either does or doesn't delegate to this builder based on the given boolean.
     * @param yes If {@code true}, then methods invoked on the returned builder will modify the state of {@code this}
     *            builder. Otherwise, methods invoked on the returned builder will not modify state.
     */
    @Nonnull
    public abstract ListBuilder&lt;T&gt; maybe(boolean yes);

    /**
     * Returns the parent list builder of a conditional list builder. This is not necessarily the originating top level
     * builder if you have nested (or rather chained) calls to {@link #maybe(boolean)}.
     */
    @Nonnull
    public abstract ListBuilder&lt;T&gt; endMaybe();

    @SuppressWarnings(&quot;unused&quot;)
    protected static class DefaultListBuilder&lt;T&gt; extends ListBuilder&lt;T&gt; {

        @Nonnull
        private final List&lt;Supplier&lt;? extends T&gt;&gt; elements;

        {
            //Linked list is good because we're mostly just appending to it, and then iterating through it.
            // Linked lists are pretty good at both.
<span class="fc" id="L310">            elements = new LinkedList&lt;&gt;();</span>
        }

<span class="fc" id="L313">        public DefaultListBuilder() {</span>

<span class="fc" id="L315">        }</span>

        /**
         * Helper method to actually build the list returned by {@link #get()}.
         *
         * &lt;p&gt;
         * This can be overridden if you need to create a different type of {@link List}. The
         * default implementation produces an {@link ArrayList}.
         *
         * &lt;p&gt;
         * Be careful how you implement this. The given {@link Supplier suppliers} should
         * be {@linkplain Supplier#get() invoked} exactly once per call to this method, and
         * they should be invoked from within this method. For instance, things like
         * {@link Lists#transform(List, Function)} do &quot;lazy&quot; evaluation which invokes the
         * supplier everytime the element is accessed in the returned list. This is &lt;em&gt;not&lt;/em&gt;
         * suitable for use with this method.
         *
         * @param suppliers An immutable list of the suppliers for the element values.
         *
         * @return A list that will be returned by this object's {@link #get()} method.
         */
        @Nonnull
        protected List&lt;T&gt; get(@Nonnull ImmutableList&lt;Supplier&lt;? extends T&gt;&gt; suppliers) {
<span class="fc" id="L338">            ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;(suppliers.size());</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">            for (Supplier&lt;? extends T&gt; supplier : suppliers) {</span>
<span class="fc" id="L340">                list.add(supplier.get());</span>
<span class="fc" id="L341">            }</span>
<span class="fc" id="L342">            return list;</span>
        }

        @Override
        @Nonnull
        protected ListBuilder&lt;T&gt; add(@Nonnull Supplier&lt;? extends T&gt; element) {
<span class="fc" id="L348">            elements.add(element);</span>
<span class="fc" id="L349">            return this;</span>
        }

        @Override
        @Nonnull
        protected ListBuilder&lt;T&gt; addSuppliers(@Nonnull Iterable&lt;? extends Supplier&lt;? extends T&gt;&gt; elements) {
<span class="fc" id="L355">            Iterables.addAll(this.elements, elements);</span>
<span class="fc" id="L356">            return this;</span>
        }

        @Override
        @Nonnull
        protected ListBuilder&lt;T&gt; addSuppliers(@Nonnull Iterator&lt;? extends Supplier&lt;? extends T&gt;&gt; elements) {
<span class="fc bfc" id="L362" title="All 2 branches covered.">            while(elements.hasNext()) {</span>
<span class="fc" id="L363">                this.elements.add(elements.next());</span>
            }
<span class="fc" id="L365">            return this;</span>
        }

        @Override
        @Nonnull
        protected ListBuilder&lt;T&gt; addSuppliers(@Nonnull Supplier&lt;? extends T&gt;[] elements) {
<span class="fc" id="L371">            return addSuppliers(Arrays.asList(elements));</span>
        }

        @Override
        @Nonnull
        protected ListBuilder&lt;T&gt; maybeAdd(@Nonnull Supplier&lt;? extends T&gt; element, boolean add) {
<span class="fc bfc" id="L377" title="All 2 branches covered.">            if(add) {</span>
<span class="fc" id="L378">                this.add(element);</span>
            }
<span class="fc" id="L380">            return this;</span>
        }

        @Override
        @Nonnull
        public ListBuilder&lt;T&gt; apply(@Nonnull Function&lt;ListBuilder&lt;T&gt;, Void&gt; function) {
<span class="fc" id="L386">            function.apply(this);</span>
<span class="fc" id="L387">            return this;</span>
        }

        /**
         * Build a new list using the elements specified for this builder.
         *
         * &lt;p&gt;
         * Note that this delegates to {@link #get(ImmutableList)}.
         * &lt;/p&gt;
         *
         * @return The built list of elements.
         */
        @Nonnull
        @Override
        public List&lt;T&gt; get() throws IncompleteBuilderException {
<span class="fc" id="L402">            return get(ImmutableList.copyOf(elements));</span>
        }

        /**
         * Returns itself.
         */
        @Override
        @Nonnull
        public ListBuilder&lt;T&gt; always() {
<span class="fc" id="L411">            return this;</span>
        }

        /**
         * Returns either {@code this} object itself, or a new {@link NeverListBuilder} if {@code yes} is {@code false}.
         */
        @Override
        @Nonnull
        public ListBuilder&lt;T&gt; maybe(boolean yes) {
<span class="fc bfc" id="L420" title="All 2 branches covered.">            if(yes) {</span>
<span class="fc" id="L421">                return this;</span>
            } else {
<span class="fc" id="L423">                return new NeverListBuilder&lt;&gt;(this, this);</span>
            }
        }

        @Nonnull
        @Override
        public ListBuilder&lt;T&gt; endMaybe() {
<span class="fc" id="L430">            return this;</span>
        }

    }

    /**
     * A {@link ListBuilder} which doesn't actually do anything.
     */
<span class="fc" id="L438">    protected static class NeverListBuilder&lt;T&gt; extends ListBuilder&lt;T&gt; {</span>

        @Nonnull
        private final ListBuilder&lt;T&gt; alwaysBuilder;

        @Nonnull
        private final ListBuilder&lt;T&gt; parent;

<span class="fc" id="L446">        protected NeverListBuilder(@Nonnull ListBuilder&lt;T&gt; alwaysBuilder, @Nonnull ListBuilder&lt;T&gt; parent) {</span>
<span class="fc" id="L447">            this.alwaysBuilder = alwaysBuilder;</span>
<span class="fc" id="L448">            this.parent = parent;</span>
<span class="fc" id="L449">        }</span>

        @Override
        @Nonnull
        protected ListBuilder&lt;T&gt; add(@Nonnull Supplier&lt;? extends T&gt; element) {
<span class="fc" id="L454">            return this;</span>
        }

        @Override
        @Nonnull
        protected ListBuilder&lt;T&gt; addSuppliers(@Nonnull Iterable&lt;? extends Supplier&lt;? extends T&gt;&gt; elements) {
<span class="fc" id="L460">            return this;</span>
        }

        @Override
        @Nonnull
        protected ListBuilder&lt;T&gt; addSuppliers(@Nonnull Iterator&lt;? extends Supplier&lt;? extends T&gt;&gt; elements) {
<span class="fc" id="L466">            return this;</span>
        }

        @Override
        @Nonnull
        protected ListBuilder&lt;T&gt; addSuppliers(@Nonnull Supplier&lt;? extends T&gt;[] elements) {
<span class="fc" id="L472">            return this;</span>
        }

        @Override
        @Nonnull
        protected ListBuilder&lt;T&gt; maybeAdd(@Nonnull Supplier&lt;? extends T&gt; element, boolean add) {
<span class="fc" id="L478">            return this;</span>
        }

        /**
         * Note that the never build &lt;em&gt;does not&lt;/em&gt; invoke the given function at all, it simply returns itself, as usual.
         */
        @Nonnull
        @Override
        public ListBuilder&lt;T&gt; apply(@Nonnull Function&lt;ListBuilder&lt;T&gt;, Void&gt; function) {
<span class="fc" id="L487">            return this;</span>
        }

        /**
         * Returns the originating (non-conditional) list builder.
         */
        @Override
        @Nonnull
        public ListBuilder&lt;T&gt; always() {
<span class="fc" id="L496">            return alwaysBuilder;</span>
        }

        /**
         * Returns a new {@link NeverListBuilder} itself. Chaining two &quot;maybe&quot; calls is like an AND: so if this AND that,
         * then change the state of the builder. But if the first one is already false, it doesn't matter what the second
         * one is, the aggregate is false.
         */
        @Override
        @Nonnull
        public ListBuilder&lt;T&gt; maybe(boolean yes) {
<span class="fc" id="L507">            return new NeverListBuilder&lt;&gt;(alwaysBuilder, this);</span>
        }

        @Nonnull
        public ListBuilder&lt;T&gt; endMaybe() {
<span class="fc" id="L512">            return parent;</span>
        }

        /**
         * Delegates to the originating (non-conditional) list builder.
         */
        @Override
        @Nonnull
        public List&lt;T&gt; get() throws IncompleteBuilderException {
<span class="fc" id="L521">            return alwaysBuilder.get();</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>