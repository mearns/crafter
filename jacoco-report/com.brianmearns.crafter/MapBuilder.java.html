<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MapBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">crafter</a> &gt; <a href="index.source.html" class="el_package">com.brianmearns.crafter</a> &gt; <span class="el_source">MapBuilder.java</span></div><h1>MapBuilder.java</h1><pre class="source lang-java linenums">package com.brianmearns.crafter;

import com.google.common.base.Function;
import com.google.common.base.Supplier;
import com.google.common.base.Suppliers;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.*;

/**
 * A {@link Builder} of {@linkplain Map map} objects.
 *
 * &lt;p&gt;
 * Map elements are {@linkplain #put(Object, Object) put} into the builder as a key and its value. Putting the same
 * key again will effectively replace previous value associated with that key.
 * &lt;/p&gt;
 *
 * @author Brian Mearns &lt;bmearns@ieee.org&gt;
 */
@SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L23">public abstract class MapBuilder&lt;K, V&gt; implements Builder&lt;Map&lt;K,V&gt;&gt; {</span>

    /**
     * Create a new builder instance which will build {@link Map Map&lt;K,V&gt;} instances.
     *
     * @param &lt;K&gt; The type for the keys that will be put into the built maps.
     * @param &lt;V&gt; The type for the value that will be put into the built maps.
     *
     * @return The newly constructed {@link MapBuilder}.
     */
    @NotNull
    @Contract(&quot;-&gt; !null&quot;)
    public static &lt;K,V&gt; MapBuilder&lt;K,V&gt; create() {
<span class="fc" id="L36">        return new DefaultMapBuilder&lt;&gt;();</span>
    }

    /**
     * Create a new builder instance which will build {@link Map Map&lt;K,V&gt;} instances.
     *
     * &lt;p&gt;
     *     This is an alternative convenience interface over {@link #create()} with no args. Instead of specifying
     *     type parameters on the method call, you can just pass in the classes you want to use and the compiler will
     *     determine the correct type parameters automatically.
     * &lt;/p&gt;
     *
     * @param keyCls The class of keys that will be put into the build maps.
     * @param valueCls The class of values that will be put into the build maps.
     *
     * @param &lt;K&gt; The type for the keys that will be put into the built maps.
     * @param &lt;V&gt; The type for the value that will be put into the built maps.
     *
     * @return The newly constructed {@link MapBuilder}.
     */
    @NotNull
    @Contract(&quot;_, _ -&gt; !null&quot;)
    @SuppressWarnings(&quot;unused&quot;)
    public static &lt;K,V&gt; MapBuilder&lt;K,V&gt; create(@NotNull Class&lt;K&gt; keyCls, @NotNull Class&lt;V&gt; valueCls) {
<span class="fc" id="L60">        return new DefaultMapBuilder&lt;&gt;();</span>
    }

    /**
     * This is the implementation specific method for putting a value in the map.
     *
     * @param key The key to add (or replace) in the map.
     * @param valueSupplier A {@link Supplier} for the value to put in the map.
     */
    protected abstract void putSupplier(@Nullable K key, @NotNull Supplier&lt;? extends V&gt; valueSupplier);

    /**
     * Put the given value in the builder's map.
     *
     * @param key The key at which to put the {@code value}.
     * @param value The value to put at the given {@code key}.
     *
     * @return This builder instance itself, for chaining convenience.
     */
    public MapBuilder&lt;K,V&gt; put(@Nullable K key, @Nullable V value) {
<span class="fc" id="L80">        putSupplier(key, Suppliers.ofInstance(value));</span>
<span class="fc" id="L81">        return this;</span>
    }

    /**
     * Put a value in the builder's map, represented by a Builder of that value.
     *
     * &lt;p&gt;
     * Note that the given Builder is not {@linkplain Builder#get() invoked} to build the value
     * right away, it is invoked once for each call to {@link #get()}.
     *
     * @param key The key at which to put the {@code value}.
     * @param value The value to put at the given {@code key}.
     *
     * @return This builder instance itself, for chaining convenience.
     */
    public MapBuilder&lt;K,V&gt; put(@Nullable K key, @NotNull Builder&lt;? extends V&gt; value) {
<span class="fc" id="L97">        putSupplier(key, value);</span>
<span class="fc" id="L98">        return this;</span>
    }

    /**
     * Place the given key-value pair in the builder, if and only if the
     * given boolean is {@code true}. Otherwise has no effect on the state of the builder.
     *
     * @param key The key at which to put the {@code value}.
     * @param value The value to put at the given {@code key}.
     * @param put Whether or not to actually update the builder.
     *
     * @return This builder instance itself, for chaining convenience.
     */
    public MapBuilder&lt;K,V&gt; maybePut(@Nullable K key, @Nullable V value, boolean put) {
<span class="fc bfc" id="L112" title="All 2 branches covered.">        if(put) {</span>
<span class="fc" id="L113">            putSupplier(key, Suppliers.ofInstance(value));</span>
        }
<span class="fc" id="L115">        return this;</span>
    }

    /**
     * Place the given key-value pair in the builder, if and only if the
     * given boolean is {@code true}. Otherwise has no effect on the state of the builder.
     *
     * @param key The key at which to put the {@code value}.
     * @param value Builder of the value to put at the given {@code key}.
     * @param put Whether or not to actually update the builder.
     *
     * @return This builder instance itself, for chaining convenience.
     */
    public MapBuilder&lt;K,V&gt; maybePut(@Nullable K key, @NotNull Builder&lt;? extends V&gt; value, boolean put) {
<span class="fc bfc" id="L129" title="All 2 branches covered.">        if(put) {</span>
<span class="fc" id="L130">            putSupplier(key, value);</span>
        }
<span class="fc" id="L132">        return this;</span>
    }

    /**
     * Apply the given function to {@code this} object, and return {@code this} object again.
     *
     * &lt;p&gt;
     * This is simply a way to add some arbitrary code in the middle of a chain of method invocations.
     * You could use the {@link Function} to perform some complex logic to configure the builder, for instance.
     *
     * &lt;p&gt;
     * The return value of the function is ignored, but for safety and clarity, it should be a void return.
     *
     * @param function The {@link Function} to be invoked on {@code this} object.
     *
     * @return This {@code MapBuilder} itself, for chaining convenience.
     */
    public abstract MapBuilder&lt;K,V&gt; apply(Function&lt;MapBuilder&lt;K,V&gt;, Void&gt; function);

    @Override
    @NotNull
    public abstract Map&lt;K, V&gt; get();


    @NotNull
    public abstract MapBuilder&lt;K, V&gt; maybe(boolean yes);

    @NotNull
    public abstract MapBuilder&lt;K, V&gt; endMaybe();

    @NotNull
    public abstract MapBuilder&lt;K, V&gt; always();

    protected static class DefaultMapBuilder&lt;K, V&gt; extends MapBuilder&lt;K, V&gt; {
        @NotNull
        private List&lt;Entry&lt;K,V&gt;&gt; entries;

<span class="fc" id="L169">        public DefaultMapBuilder() {</span>
<span class="fc" id="L170">            entries = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L171">        }</span>

        @Override
        @NotNull
        @Contract(&quot;-&gt; !null&quot;)
        public Map&lt;K, V&gt; get() {
<span class="fc" id="L177">            return buildMap(entries);</span>
        }

        @NotNull
        @Override
        public MapBuilder&lt;K, V&gt; maybe(boolean yes) {
<span class="fc bfc" id="L183" title="All 2 branches covered.">            if(yes) {</span>
<span class="fc" id="L184">                return this;</span>
            }
<span class="fc" id="L186">            return new NeverMapBuilder&lt;&gt;(this, this);</span>
        }

        @Override
        @NotNull
        public MapBuilder&lt;K, V&gt; endMaybe() {
<span class="fc" id="L192">            return this;</span>
        }

        @Override
        @NotNull
        public MapBuilder&lt;K, V&gt; always() {
<span class="fc" id="L198">            return this;</span>
        }

        /**
         * Helper function called from {@link #get()} to actually build and populate
         * the map with the given entries. This makes it easier to override if you want to
         * create a different type of map.
         *
         * This will typically delegate to {@link #createMap(int)}.
         */
        @NotNull
        protected Map&lt;K, V&gt; buildMap(@NotNull List&lt;Entry&lt;K,V&gt;&gt; entries) {
<span class="fc" id="L210">            Map&lt;K,V&gt; map = createMap(entries.size());</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">            for(Entry&lt;K,V&gt; entry : entries) {</span>
<span class="fc" id="L212">                map.put(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L213">            }</span>
<span class="fc" id="L214">            return map;</span>
        }

        /**
         * Helper methods called by {@link #buildMap(List)} to create the initial map. This is the easiest
         * way to override the implementation of the Map interface you want to use.
         *
         * @param size The approximate number of entries that the map will need to hold initially.
         */
        @NotNull
        protected Map&lt;K, V&gt; createMap(int size) {
<span class="fc" id="L225">            return new HashMap&lt;&gt;(size);</span>
        }

        @Override
        protected void putSupplier(@Nullable K key, @NotNull Supplier&lt;? extends V&gt; valueSupplier) {
<span class="fc" id="L230">            entries.add(new Entry&lt;&gt;(key, valueSupplier));</span>
<span class="fc" id="L231">        }</span>

        @Override
        public MapBuilder&lt;K,V&gt; apply(Function&lt;MapBuilder&lt;K,V&gt;, Void&gt; function) {
<span class="fc" id="L235">            function.apply(this);</span>
<span class="fc" id="L236">            return this;</span>
        }

        private static class Entry&lt;K,V&gt; {
            @Nullable
            private final K key;

            @NotNull
            private final Supplier&lt;? extends V&gt; value;

<span class="fc" id="L246">            protected Entry(@Nullable K key, @NotNull Supplier&lt;? extends V&gt; value) {</span>
<span class="fc" id="L247">                this.key = key;</span>
<span class="fc" id="L248">                this.value = value;</span>
<span class="fc" id="L249">            }</span>

            @Nullable
            public K getKey() {
<span class="fc" id="L253">                return key;</span>
            }

            @Nullable
            public V getValue() {
<span class="fc" id="L258">                return value.get();</span>
            }
        }
    }

<span class="fc" id="L263">    protected static class NeverMapBuilder&lt;K, V&gt; extends MapBuilder&lt;K, V&gt; {</span>

        @NotNull
        private final MapBuilder&lt;K, V&gt; alwaysBuilder;

        @NotNull
        private final MapBuilder&lt;K, V&gt; parent;

<span class="fc" id="L271">        protected NeverMapBuilder(@NotNull MapBuilder&lt;K, V&gt; alwaysBuilder, @NotNull MapBuilder&lt;K, V&gt; parent) {</span>
<span class="fc" id="L272">            this.alwaysBuilder = alwaysBuilder;</span>
<span class="fc" id="L273">            this.parent = parent;</span>
<span class="fc" id="L274">        }</span>

        @Override
        protected void putSupplier(@Nullable K key, @NotNull Supplier&lt;? extends V&gt; valueSupplier) {
            //Do nothing;
<span class="fc" id="L279">        }</span>

        @Override
        public MapBuilder&lt;K, V&gt; apply(Function&lt;MapBuilder&lt;K, V&gt;, Void&gt; function) {
<span class="fc" id="L283">            return this;</span>
        }

        @NotNull
        @Override
        public Map&lt;K, V&gt; get() {
<span class="fc" id="L289">            return alwaysBuilder.get();</span>
        }

        @NotNull
        @Override
        public MapBuilder&lt;K, V&gt; maybe(boolean yes) {
<span class="nc" id="L295">            return new NeverMapBuilder&lt;&gt;(alwaysBuilder, this);</span>
        }

        @NotNull
        @Override
        public MapBuilder&lt;K, V&gt; endMaybe() {
<span class="nc" id="L301">            return parent;</span>
        }

        @NotNull
        @Override
        public MapBuilder&lt;K, V&gt; always() {
<span class="nc" id="L307">            return alwaysBuilder;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>