<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MapBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">crafter</a> &gt; <a href="index.source.html" class="el_package">com.brianmearns.crafter</a> &gt; <span class="el_source">MapBuilder.java</span></div><h1>MapBuilder.java</h1><pre class="source lang-java linenums">package com.brianmearns.crafter;

import com.google.common.base.Function;
import com.google.common.base.Supplier;
import com.google.common.base.Suppliers;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

/**
 * A {@link BuilderInterface} of {@linkplain Map map} objects.
 *
 * &lt;p&gt;
 * Map elements are {@linkplain #put(Object, Object) put} into the builder as a key and its value. Putting the same
 * key again will effectively replace previous value associated with that key.
 * &lt;/p&gt;
 *
 * @author Brian Mearns &lt;bmearns@ieee.org&gt;
 */
@SuppressWarnings(&quot;unused&quot;)
<span class="fc" id="L25">public abstract class MapBuilder&lt;K, V&gt; implements BuilderInterface&lt;Map&lt;K,V&gt;&gt; {</span>

    /**
     * Create a new builder instance which will build {@link Map Map&lt;K,V&gt;} instances.
     *
     * @param &lt;K&gt; The type for the keys that will be put into the built maps.
     * @param &lt;V&gt; The type for the value that will be put into the built maps.
     *
     * @return The newly constructed {@link MapBuilder}.
     */
    @Nonnull
    public static &lt;K,V&gt; MapBuilder&lt;K,V&gt; create() {
<span class="fc" id="L37">        return new DefaultMapBuilder&lt;&gt;();</span>
    }

    /**
     * Create a new builder instance which will build {@link Map Map&lt;K,V&gt;} instances.
     *
     * &lt;p&gt;
     *     This is an alternative convenience interface over {@link #create()} with no args. Instead of specifying
     *     type parameters on the method call, you can just pass in the classes you want to use and the compiler will
     *     determine the correct type parameters automatically.
     * &lt;/p&gt;
     *
     * @param keyCls The class of keys that will be put into the build maps.
     * @param valueCls The class of values that will be put into the build maps.
     *
     * @param &lt;K&gt; The type for the keys that will be put into the built maps.
     * @param &lt;V&gt; The type for the value that will be put into the built maps.
     *
     * @return The newly constructed {@link MapBuilder}.
     */
    @Nonnull
    public static &lt;K,V&gt; MapBuilder&lt;K,V&gt; create(@Nonnull Class&lt;K&gt; keyCls, @Nonnull Class&lt;V&gt; valueCls) {
<span class="fc" id="L59">        return new DefaultMapBuilder&lt;&gt;();</span>
    }

    /**
     * This is the implementation specific method for putting a value in the map.
     *
     * @param key The key to add (or replace) in the map.
     * @param valueSupplier A {@link Supplier} for the value to put in the map.
     */
    protected abstract void putSupplier(@Nullable K key, @Nonnull Supplier&lt;? extends V&gt; valueSupplier);

    /**
     * Put the given value in the builder's map.
     *
     * @param key The key at which to put the {@code value}.
     * @param value The value to put at the given {@code key}.
     *
     * @return This builder instance itself, for chaining convenience.
     */
    public MapBuilder&lt;K,V&gt; put(@Nullable K key, @Nullable V value) {
<span class="fc" id="L79">        putSupplier(key, Suppliers.ofInstance(value));</span>
<span class="fc" id="L80">        return this;</span>
    }

    /**
     * Put a value in the builder's map, represented by a BuilderInterface of that value.
     *
     * &lt;p&gt;
     * Note that the given builder is not {@linkplain BuilderInterface#get() invoked} to build the value
     * right away, it is invoked once for each call to {@link #get()}.
     *
     * @param key The key at which to put the {@code value}.
     * @param value The value to put at the given {@code key}.
     *
     * @return This builder instance itself, for chaining convenience.
     */
    public MapBuilder&lt;K,V&gt; put(@Nullable K key, @Nonnull BuilderInterface&lt;? extends V&gt; value) {
<span class="fc" id="L96">        putSupplier(key, value);</span>
<span class="fc" id="L97">        return this;</span>
    }

    /**
     * Place the given key-value pair in the builder, if and only if the
     * given boolean is {@code true}. Otherwise has no effect on the state of the builder.
     *
     * @param key The key at which to put the {@code value}.
     * @param value The value to put at the given {@code key}.
     * @param put Whether or not to actually update the builder.
     *
     * @return This builder instance itself, for chaining convenience.
     */
    public MapBuilder&lt;K,V&gt; maybePut(@Nullable K key, @Nullable V value, boolean put) {
<span class="fc bfc" id="L111" title="All 2 branches covered.">        if(put) {</span>
<span class="fc" id="L112">            putSupplier(key, Suppliers.ofInstance(value));</span>
        }
<span class="fc" id="L114">        return this;</span>
    }

    /**
     * Place the given key-value pair in the builder, if and only if the
     * given boolean is {@code true}. Otherwise has no effect on the state of the builder.
     *
     * @param key The key at which to put the {@code value}.
     * @param value Builder of the value to put at the given {@code key}.
     * @param put Whether or not to actually update the builder.
     *
     * @return This builder instance itself, for chaining convenience.
     */
    public MapBuilder&lt;K,V&gt; maybePut(@Nullable K key, @Nonnull BuilderInterface&lt;? extends V&gt; value, boolean put) {
<span class="fc bfc" id="L128" title="All 2 branches covered.">        if(put) {</span>
<span class="fc" id="L129">            putSupplier(key, value);</span>
        }
<span class="fc" id="L131">        return this;</span>
    }

    /**
     * Apply the given function to {@code this} object, and return {@code this} object again.
     *
     * &lt;p&gt;
     * This is simply a way to add some arbitrary code in the middle of a chain of method invocations.
     * You could use the {@link Function} to perform some complex logic to configure the builder, for instance.
     *
     * &lt;p&gt;
     * The return value of the function is ignored, but for safety and clarity, it should be a void return.
     *
     * @param function The {@link Function} to be invoked on {@code this} object.
     *
     * @return This {@code MapBuilder} itself, for chaining convenience.
     */
    public abstract MapBuilder&lt;K,V&gt; apply(Function&lt;MapBuilder&lt;K,V&gt;, Void&gt; function);

    @Override
    @Nonnull
    public abstract Map&lt;K, V&gt; get() throws IncompleteBuilderException;


    @Nonnull
    public abstract MapBuilder&lt;K, V&gt; maybe(boolean yes);

    @Nonnull
    public abstract MapBuilder&lt;K, V&gt; endMaybe();

    @Nonnull
    public abstract MapBuilder&lt;K, V&gt; always();

    protected static class DefaultMapBuilder&lt;K, V&gt; extends MapBuilder&lt;K, V&gt; {
        @Nonnull
        private List&lt;Entry&lt;K,V&gt;&gt; entries;

<span class="fc" id="L168">        public DefaultMapBuilder() {</span>
<span class="fc" id="L169">            entries = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L170">        }</span>

        @Override
        @Nonnull
        public Map&lt;K, V&gt; get() throws IncompleteBuilderException {
<span class="fc" id="L175">            return buildMap(entries);</span>
        }

        @Nonnull
        @Override
        public MapBuilder&lt;K, V&gt; maybe(boolean yes) {
<span class="fc bfc" id="L181" title="All 2 branches covered.">            if(yes) {</span>
<span class="fc" id="L182">                return this;</span>
            }
<span class="fc" id="L184">            return new NeverMapBuilder&lt;&gt;(this, this);</span>
        }

        @Override
        @Nonnull
        public MapBuilder&lt;K, V&gt; endMaybe() {
<span class="fc" id="L190">            return this;</span>
        }

        @Override
        @Nonnull
        public MapBuilder&lt;K, V&gt; always() {
<span class="fc" id="L196">            return this;</span>
        }

        /**
         * Helper function called from {@link #get()} to actually build and populate
         * the map with the given entries. This makes it easier to override if you want to
         * create a different type of map.
         *
         * This will typically delegate to {@link #createMap(int)}.
         */
        @Nonnull
        protected Map&lt;K, V&gt; buildMap(@Nonnull List&lt;Entry&lt;K,V&gt;&gt; entries) {
<span class="fc" id="L208">            Map&lt;K,V&gt; map = createMap(entries.size());</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">            for(Entry&lt;K,V&gt; entry : entries) {</span>
<span class="fc" id="L210">                map.put(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L211">            }</span>
<span class="fc" id="L212">            return map;</span>
        }

        /**
         * Helper methods called by {@link #buildMap(List)} to create the initial map. This is the easiest
         * way to override the implementation of the Map interface you want to use.
         *
         * @param size The approximate number of entries that the map will need to hold initially.
         */
        @Nonnull
        protected Map&lt;K, V&gt; createMap(int size) {
<span class="fc" id="L223">            return new HashMap&lt;&gt;(size);</span>
        }

        @Override
        protected void putSupplier(@Nullable K key, @Nonnull Supplier&lt;? extends V&gt; valueSupplier) {
<span class="fc" id="L228">            entries.add(new Entry&lt;&gt;(key, valueSupplier));</span>
<span class="fc" id="L229">        }</span>

        @Override
        public MapBuilder&lt;K,V&gt; apply(Function&lt;MapBuilder&lt;K,V&gt;, Void&gt; function) {
<span class="fc" id="L233">            function.apply(this);</span>
<span class="fc" id="L234">            return this;</span>
        }

        private static class Entry&lt;K,V&gt; {
            @Nullable
            private final K key;

            @Nonnull
            private final Supplier&lt;? extends V&gt; value;

<span class="fc" id="L244">            protected Entry(@Nullable K key, @Nonnull Supplier&lt;? extends V&gt; value) {</span>
<span class="fc" id="L245">                this.key = key;</span>
<span class="fc" id="L246">                this.value = value;</span>
<span class="fc" id="L247">            }</span>

            @Nullable
            public K getKey() {
<span class="fc" id="L251">                return key;</span>
            }

            @Nullable
            public V getValue() {
<span class="fc" id="L256">                return value.get();</span>
            }
        }
    }

<span class="fc" id="L261">    protected static class NeverMapBuilder&lt;K, V&gt; extends MapBuilder&lt;K, V&gt; {</span>

        @Nonnull
        private final MapBuilder&lt;K, V&gt; alwaysBuilder;

        @Nonnull
        private final MapBuilder&lt;K, V&gt; parent;

<span class="fc" id="L269">        protected NeverMapBuilder(@Nonnull MapBuilder&lt;K, V&gt; alwaysBuilder, @Nonnull MapBuilder&lt;K, V&gt; parent) {</span>
<span class="fc" id="L270">            this.alwaysBuilder = alwaysBuilder;</span>
<span class="fc" id="L271">            this.parent = parent;</span>
<span class="fc" id="L272">        }</span>

        @Override
        protected void putSupplier(@Nullable K key, @Nonnull Supplier&lt;? extends V&gt; valueSupplier) {
            //Do nothing;
<span class="fc" id="L277">        }</span>

        @Override
        public MapBuilder&lt;K, V&gt; apply(Function&lt;MapBuilder&lt;K, V&gt;, Void&gt; function) {
<span class="fc" id="L281">            return this;</span>
        }

        @Nonnull
        @Override
        public Map&lt;K, V&gt; get() throws IncompleteBuilderException {
<span class="fc" id="L287">            return alwaysBuilder.get();</span>
        }

        @Nonnull
        @Override
        public MapBuilder&lt;K, V&gt; maybe(boolean yes) {
<span class="fc" id="L293">            return new NeverMapBuilder&lt;&gt;(alwaysBuilder, this);</span>
        }

        @Nonnull
        @Override
        public MapBuilder&lt;K, V&gt; endMaybe() {
<span class="fc" id="L299">            return parent;</span>
        }

        @Nonnull
        @Override
        public MapBuilder&lt;K, V&gt; always() {
<span class="fc" id="L305">            return alwaysBuilder;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>